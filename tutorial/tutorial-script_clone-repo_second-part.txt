Let me first give a quick introduction on what we are going to build. 
We are going to create a smart contract that will work as a guess game. 
The contract owner will set a number and the players will need to guess what number is. 
If they guess is wrong, the contract will tell if the number is lower or higher than the guess. 
If it's right, the contract reset the game and the owner will be able to set another one. 
Players can also pay a small fee to reveal the number, so they can easily win the game.
It seems simple but we will be able to learn some basic concepts of AssemblyScript and who smart contracts work on the NEAR blockchains.

// 1.ts
Basically, the only file that we are going to work on is the index.ts file inside the assembly directory.

We are going to start by creating a couple of functions.

The first one we will call setNumber.
Export means it's public, that will be possible to call it from outside the contract, using the command line tool.
It will receive a parameter called number of type u8, that is a type of integer that can only stores a number from 0 to 255. More about types, check the AssemblyScript documentation linked in the description.
Let's use this limitation in our favor and make it a rule for the game. The number to be guessed will be inside this range.
The word after colon is the data type that will be returned by the function. In this case void, which means that the function won't return nothing.

Now let's import the storage class from the NEAR SDK. This will give us useful methods for storing persistent data in the NEAR blockchain.
We will use the method set to store u8 data which will be refered by the key number and with the value that we will pass when calling this function later.

The second function will be called guessNumber that will return a string.
The method getPrimitive will look for the key number with a value of u8 type and set it to a constant called stored. If this key doesn't exist or if it's of a different type, it will use the default value set as the second parameter, in this case 0.
A good practice is to name it only capital letters so we can easily indentify it as a constant, 

The if statement will compare the guessed number with the one stored and return a string with the result.

// terminal
// asb
Let's see how to deploy it.
First we can run the command asb. It's the AssemblyScript compiler that we installed before.
By default it will look inside the assembly directory for a file called index.ts, compile it into a WebAssembly program and save it in the path build/release with the same name as defined in the package.json of the project with the extension wasm.

Now to deploy it to the NEAR blockchain we will use the near command. Let's see how to do it by running near deploy --help

// terminal
// near deploy --help

It asks for the account ID where the contract will lives and the actual file to be deployed. The other arguments aren't required.

// terminal
// near deploy [accountId] ./build/release/near-tutorial.wasm

Our contract is deployed and any account on the NEAR testnet can interact with it.
But before going forward, let's create a script command in the package.json file to easily compile and deploy because we are going to do it many times.

// package.json
// "deploy": "asb && near deploy tutorial.theclash.testnet ./build/release/near-tutorial.wasm -f"

There are two ways to do it using the near tool, one is by using the call command and the other is with the view command. Which one to use depends of the type of function that your are interacting with.
"View" functions are the ones that doesn't change the state of the blockchain and can't also call some methods of the NEAR core. Check the "NEAR AssemblyScript smart contracts introduction" for more details, the link is in the description.
The other type of function is called "change". Those are the ones that can to what "view" functions can't.
In our case setNumber is a "change" function and guessNumber a "view" one. It will change later because guessNumber will also change the state of the blockchain, so for now we can use the view command to interact with it.
But first, let's call the setNumber and set a number.
The contractName is the account where the contract was deployed, methodName is setNumber and inside single quotes and curly brackets. The parameter we put inside double quotes because the name of itself is a string and the value in this because is a number we don't need quotes. The accountId option is the account who is making the call. We can use the same as the contract. 

// terminal
// near call --help
// near call [accountId] setNumber '{"number": 77}' --accountId [accountId]

Now let's make a guess by using the view command. It's the same thing that the one before, but you don't need to specifies who is making the request.

// terminal
// near view [accountId] guessNumber '{"number": 55}'
// near view [accountId] guessNumber '{"number": 99}'
// near view [accountId] guessNumber '{"number": 77}'

Now let's do some improvements on our contract.

// 2.ts
The assert method has too paremeters. The first is a condition that needs to be true to continue. If it's false the contract will throw an error with the message in the second parameter.

Since the default value for the stored number is 0, we will let it out of the number to be guessed range.

The first assert makes sure that the number won't be changed if nobody guessed it right. 

The second one makes sure the number to be set is inside the range.

On the guessNumber function, we make sure that someone can play the game only if there's a number to guess. If it's zero, there's no game.

If someone win the game, we change the number back to zero and the contract owner will be allowed to set a new one. Now it's not a view function anymore because we are changing the state, so you will get an error if you try to do it.

// 3.ts
Since we are using the same getPrimitive method twice to get the number stored, let's create a private function that will return the number for us.
The difference from a public one is very simple: there's no export in the begining. As a private function, nobody is allowed to call this function besides other functions of the contract.

A good practice is to use an underline in the begining of the name of a private function, so we can easily indentify when coding.

We also are going to create a private function that will check if the account is the owner of the contract. For this we are going to need another class from the NEAR SDK called context. It has some useful properties that we can use for it like contractName that gives us the account where the contract is deployed and "sender" that give us the account who is making the request.

The whoAmI and contractAccount functions will help us to visualize it, but they aren't needed for out contract. Try to make view and call requests to them and see the results. You will get an error when trying to view the whoAmI function because context.sender is one of the methods not allowed for this kind of function.
You won't have a problem by using either the call and view commands for the contractAccount function.

Let's comment these two functions and keep doing improvements to our contract.

// 4.ts
We are now going to create another function that players can call and reveal the number by paying a little fee, but first let's see how the NEAR token value is stored.
It uses an special type called u128 that the AssemblyScript doesn't have but it's provided by the NEAR SDK.
The attachedDeposit function returns the context.attachedDeposit.

// terminal
// near call [accountId] attachedDeposit --accountId [accountId] --ammount 1

By using the "amount" option we can attach NEAR tokens to our call.
See the big number that was returned? This is how one NEAR token value is stored.
Let's copy this big number and set it to a global constant in our contract.
I like to name it with all capital letters so when I'm coding I know they are global, which means that it can be accessed for any functions in our contract and that it's a constant, so don't even try to change its value anywhere in our code.
The fromString method will transform a string in a u128 number.

Let's go back and finish our contract.

// 5.ts
Using the assert method we can check if at least one near is attached to the call or if the one who is calling is the owner of the contract. If at least one of these conditions is true, it will return the number to be guessed.

That's it for this video, but I would like to give a challenge to you.
It would be cool if our contract could show the players who had won the game.
Would you like to give a try? I will give you some tips to help you complete this challenge:
Go to the "NEAR AssemblyScript smart contracts introduction" that is linked in the description and look for some information about collections, specially the one called PersistentMap. It's almost like an array, but instead of having a numbered index for each value, it has a key that you can set that refers to a value.
You can use it to store the accountId as key and the number that was guessed, or maybe the timestamp, which is a complex subject for blockchains, as value, then make a function that can be viewed to return the list of winners.
If you are having a hard time to do implement it or want to connect with others interested in NEAR smart contract development, go to the NEAR Discord server or reach out to me on Twitter. The links are in the description.

I hope you liked this video and thanks for watching. 
See you around. Bye!